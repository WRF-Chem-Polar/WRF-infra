# Copyright (c) 2025 LATMOS (France, UMR 8190) and IGE (France, UMR 5001).
#
# License: BSD 3-clause "new" or "revised" license (BSD-3-Clause).

"""Compile WRF."""

import sys
import os.path
import commons as cms


def prepare_components(opts):
    """Prepare WRF components.

    Parameters
    ----------
    opts: Namespace
        The pre-processed user-defined installation options.

    Returns
    -------
    str
        The WRF options, formatted to be passed to the configure script.

    """
    return " " + " ".join(opts.components) if opts.components else ""


def prepare_environment_variables(opts):
    """Prepare the compilation environment variables.

    Parameters
    ----------
    opts: Namespace
        The pre-processed user-defined installation options.

    Returns
    -------
    [str]
        The lines setting environment variables.

    """
    host = cms.identify_host_platform()
    env_vars = {
        "EM_CORE": 1,
        "NMM_CORE": 0,
        "NETCDF": "$NETCDF_FORTRAN_ROOT",
        "HDF5": "$HDF5_ROOT",
    }
    # For some reason, just using the chem and kpp options is not enough, one
    # also has to explicitly set the corresponding environment variables
    if "chem" in opts.components:
        env_vars["WRF_CHEM"] = 1
    if "kpp" in opts.components:
        env_vars["WRF_KPP"] = 1
    # If non-standard, specify the location of the flex library explicitly
    if host == "spirit":
        env_vars["FLEX_LIB_DIR"] = "/usr/lib/x86_64-linux-gnu"
    # For KPP, we want header files to also be generated by (b)yacc (option -d)
    env_vars["YACC"] = "byacc -d"
    return [
        f"export {name}={cms.format_shell_value(value)}"
        for name, value in env_vars.items()
    ]


def write_job_script(opts):
    """Create the job script.

    Parameters
    ----------
    opts: Namespace
        The pre-processed user-defined installation options.

    """
    # Platform, directories, and files
    host = cms.identify_host_platform()
    envfile = os.path.join(cms.path_of_repo(), "env", f"{host}.sh")
    script = os.path.join(opts.destination, "compile.job")

    # Prepare header of file (hash bang and scheduler options)
    lines = ["#!/bin/bash"]
    if opts.scheduler:
        if host in ("spirit",):
            lines += cms.prepare_slurm_options("03:00:00")
        else:
            raise NotImplementedError("Unsupported host: %s." % host)

    # Platform-specific environment
    with open(envfile) as f:
        env = [line.strip() for line in f]
    lines += [line for line in env if line and not line.startswith("#")]
    lines += prepare_environment_variables(opts)
    setup = {"spirit": 34}[host]
    nesting = 1

    # Add the call to ./configure
    lines.append('echo -e "%d\\n%d" | \\' % (setup, nesting))
    lines.append(f"./configure{prepare_components(opts)}")

    # Add the call to ./compile
    lines.append(f"./compile {opts.executable}")

    # Write the script
    with open(script, mode="x") as f:
        f.write("\n".join(lines))
        f.write("\n")
    os.chmod(script, 0o744)


if __name__ == "__main__":
    # Actually do the work (parse user options, checkout, compile)

    host = cms.identify_host_platform()
    opts = cms.get_options("WRF")

    cms.clone_and_checkout(opts)
    cms.write_options(opts)
    write_job_script(opts)
    cms.process_patches(opts)
    cms.process_extra_sources(opts)

    if opts.dry:
        sys.exit(0)

    if opts.scheduler:
        cmd = [{"spirit": "sbatch"}[host], "compile.job"]
    else:
        cmd = ["./compile.job"]
    cms.run(cmd, cwd=opts.destination)
